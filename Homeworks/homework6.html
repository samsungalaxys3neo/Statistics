<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Titolo aggiornato a Homework_6 -->
  <title>Homework_6 | Incremental Algorithms</title>
  
  <link href="https://fonts.cdnfonts.com/css/cascadia-code" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- MathJax for rendering LaTeX formulas -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  
  <!-- MathJax Configuration (to enable $...$ for inline math) -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: {
        fontCache: 'global'
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  <style>
    :root {
      --bg: #0a0010;
      --accent: #b6ffb6;
      --accent-dim: rgba(182,255,182,.25);
      --accent-2: #ff8c00; /* A second accent for charts */
      --glow: #b6ffb6;
      --text: #f4fff7;
      --subtitle: #8aff8a;
      --code-bg: #171717;
      --container-bg: rgba(0,0,0,0.85);
    }
    
    body.cyberpunk-mode {
      --bg: #000;
      --accent: #ff00cc;
      --accent-dim: rgba(255,0,204,.25);
      --accent-2: #00f0ff; /* Cyberpunk secondary accent */
      --glow: #ff00cc;
      --text: #eaffef;
      --subtitle: #ff88ff;
      --code-bg: #1a001a;
      --container-bg: rgba(10, 0, 20, 0.85);
    }
    
    *{margin:0;padding:0;box-sizing:border-box}
    
    body{
      background:var(--bg);
      color:var(--text);
      font-family:'Cascadia Code', monospace;
      padding:2rem;
      transition:background .6s ease, color .6s ease;
      overflow-x: hidden;
    }
    
    /* Style for MathJax output */
    mjx-container {
      color: var(--text);
      margin: 1rem 0;
      text-align: center;
      overflow-x: auto;
      overflow-y: hidden;
      /* Assicura che anche il testo renderizzato da MathJax cambi colore con il tema */
      transition: color .6s ease;
    }
    
    #toggle{position:fixed;top:16px;right:16px;padding:.55rem 1rem;border:none;border-radius:10px;cursor:pointer;background:linear-gradient(145deg,var(--accent),var(--glow));color:#000;font-weight:bold;box-shadow:0 0 12px var(--glow),inset 0 0 5px rgba(255,255,255,.2); z-index: 100;}
    #toggle:hover{transform:scale(1.05);box-shadow:0 0 18px var(--glow);}
    
    .container{max-width:900px;margin:6rem auto;padding:2rem 2.5rem;background:var(--container-bg);border:1px solid var(--accent-dim);border-radius:12px;box-shadow:0 0 20px var(--accent-dim), inset 0 0 10px rgba(255,255,255,0.05); transition: background .6s ease, border .6s ease;}
    
    h1,h2,h3,h4{color:var(--accent);text-shadow:0 0 8px var(--glow);text-align:center; transition: color .6s ease, text-shadow .6s ease;}
    /* Titoli aggiornati */
    h1{font-size:2.3rem;margin-bottom:.4rem;}
    /* Rimosso font-style: italic; */
    h2{font-size:1.1rem;margin-bottom:2.5rem;opacity:.9; line-height: 1.6; padding: 0 1rem;}
    
    h3{margin-top:2.5rem;margin-bottom:1.2rem;color:var(--subtitle); font-size: 1.4rem; border-bottom: 1px solid var(--accent-dim); padding-bottom: 0.5rem; text-align: left; transition: color .6s ease, border-bottom .6s ease;}
    h4{margin-top:1.5rem;margin-bottom:.5rem;font-size:1.1rem;color:var(--subtitle); text-align: left;}
    
    p{margin-bottom:1rem;line-height:1.7; opacity: 0.9;}
    /* Aggiunto stile per il tag <code> all'interno dei paragrafi */
    p code {
      color: var(--subtitle);
      background: var(--code-bg);
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-size: 0.9em;
      transition: color .6s ease, background .6s ease;
    }
    p strong { color: var(--subtitle); font-weight: bold; }
    ul { margin-left: 2rem; margin-bottom: 1rem; line-height: 1.7; }
    li { margin-bottom: 0.5rem; }

    /* Box per le formule */
    .formula-box{background:var(--code-bg);color:var(--text);border:1px solid var(--accent-dim);border-radius:10px;padding: 0.5rem 1.2rem;font-family:'Cascadia Code',monospace;overflow-x:auto;margin-top:1rem;margin-bottom:1.5rem;font-size:1.1rem;text-align:center;line-height:1.8; box-shadow: inset 0 0 8px rgba(0,0,0,0.3); transition: background .6s ease, border .6s ease;}
    
    /* Box per il codice */
    .sql-box{
      background:var(--code-bg);
      color:#ffffff;
      border:1px solid var(--accent-dim);
      border-radius:10px;
      padding:1rem 1.2rem;
      font-family:'Cascadia Code', monospace;
      overflow-x:auto;
      margin-top:1rem;
      margin-bottom:1.5rem;
      box-shadow:inset 0 0 8px rgba(0,0,0,0.3);
      font-size: 0.9rem;
      white-space: pre-wrap; /* Mantiene la formattazione */
      word-wrap: break-word; /* Va a capo se necessario */
      transition: background .6s ease, border .6s ease;
    }
    .sql-keyword{color:#0074d9;font-weight:bold;}
    .sql-string{color:#b03060;}
    .sql-number{color:#2e8b57;}
    .sql-comment{color:#50a150;}
    .sql-class{color:#D4A00E; font-weight: bold;}
    .sql-method{color:#8E68FF;}

    /* Output per simulazione */
    #simOutput {
      background:rgba(0,0,0,0.8);
      padding: 1.5rem;
      border-radius:10px;
      font-family:'Cascadia Code',monospace;
      font-size:0.95rem;
      line-height:1.7;
      color:var(--accent);
      box-shadow:0 0 15px var(--accent-dim),inset 0 0 10px rgba(255,255,255,0.05);
      white-space:pre-wrap;
      word-wrap: break-word;
      min-height:150px;
      overflow-wrap:break-word;
      transition: color .6s ease, box-shadow .6s ease;
      margin-top: 1rem;
    }
    
    canvas{
      display:block;
      margin:2rem auto;
      background:rgba(0,0,0,0.8);
      border-radius:10px;
      box-shadow:0 0 20px var(--accent-dim);
      width: 100% !important; /* Force Chart.js to be responsive */
      max-height: 400px;
    }
    
    .btn{
      display:block;
      margin:1.5rem auto 1rem auto;
      background:transparent;
      border:1px solid var(--accent-dim);
      color:var(--accent);
      padding:.7rem 1.2rem;
      border-radius:8px;
      cursor:pointer;
      font-size: 1rem;
      font-family: 'Cascadia Code', monospace;
      text-shadow:0 0 8px var(--glow);
      transition:.25s;
      box-shadow: 0 0 10px var(--accent-dim);
    }
    .btn:hover{background:var(--accent);color:#000; box-shadow: 0 0 20px var(--glow);}
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      color: var(--accent-dim);
      background: transparent;
      box-shadow: none;
    }

    /* Responsive */
    @media (max-width: 768px) {
      body { padding: 1rem; }
      .container { margin: 4rem auto; padding: 1.5rem; width: 95%; }
      h1 { font-size: 1.8rem; }
      h2 { font-size: 1rem; }
      h3 { font-size: 1.2rem; }
      h4 { font-size: 1rem; }
      p, ul { font-size: 0.9rem; }
      .btn { width: 100%; font-size: 0.9rem; }
      #toggle { top: 10px; right: 10px; padding: 0.4rem 0.8rem; font-size: 0.8rem; }
    }
  </style>
</head>
<body>
  
  <button id="toggle">Cyberpunk Mode</button>
  
  <div class="container">
    <!-- Titolo e Sottotitolo aggiornati -->
    <h1>Homework_6</h1>
    <!-- Sottotitolo più corto, non in corsivo, non fra virgolette -->
    <h2>Incremental Algorithms for Mean and Variance</h2>

    <h3>&gt; Section 1: Problem Definition</h3>
    <p>The task is to analyze and implement "online" (or incremental) algorithms for calculating mean and variance. An online algorithm processes data sequentially, one sample at a time, and updates the current statistics without storing the entire dataset.</p>
    <p>This approach is fundamental in scenarios with data streams (e.g., IoT sensors, real-time financial analysis, or network logs) where the data is too voluminous to be stored or arrives in an endless flow.</p>

    <!-- NUOVA SEZIONE 2: Svantaggi del Batch -->
    <h3>&gt; Section 2: The "Batch" Algorithm Problem</h3>
    <p>The assignment emphasizes that traditional "batch" algorithms, which require the entire dataset in memory, are unsuitable. This is for three fundamental reasons:</p>
    
    <h4>▶ 2.1 Computational Inefficiency (Time)</h4>
    <!-- Usato <code> invece di $...$ -->
    <p>A batch algorithm recalculates the sum and sum of squares from scratch every time. If we have <code>N</code> samples and a new one arrives, a batch algorithm re-examines all <code>N+1</code> samples. An online algorithm performs only a small, constant-time update, <code>O(1)</code>.</p>
    
    <h4>▶ 2.2 Memory Inefficiency (Space)</h4>
    <!-- Usato <code> invece di $...$ -->
    <p>The batch approach requires storing the entire dataset, demanding <code>O(N)</code> memory. This is unsustainable for very large or infinite data streams. An online algorithm requires only constant memory space, <code>O(1)</code>, to store the current statistics (e.g., <code>n</code>, <code>μ</code>, <code>M₂</code>).</p>
    
    <h4>▶ 2.3 Numerical Instability</h4>
    <p>This is the most severe flaw. Batch algorithms, especially the "two-pass" formulas for variance (first calculate the mean, then the sum of squares), are numerically unstable.</p>
    <ul>
      <li><strong>Catastrophic Cancellation:</strong> If the data values are very large but their variance is small (e.g., [1000001, 1000002, 1000003]), the formula $\sum(x_i - \mu)^2$ requires subtracting two almost identical numbers, leading to a catastrophic loss of precision.</li>
      <li><strong>Overflow:</strong> The formula $\sum x_i^2$ can easily exceed the maximum representable value (overflow) if the $x_i$ values are large, even if the final variance is small.</li>
    </ul>
    <p>Incremental algorithms like Welford's avoid these problems by never calculating $\sum x_i^2$.</p>

    <!-- SEZIONE 3: DERIVAZIONE (ex-Sezione 2) -->
    <h3>&gt; Section 3: Derivation of Recurrence Relationships</h3>
    
    <h4>▶ 3.1 Recursive Formula for the Mean (μt)</h4>
    <p>This is the "simple proof" required. We start from the mean at time $t$. The total sum $\sum_{i=1}^t x_i$ is the sum up to $t-1$ plus the new sample $x_t$. We substitute $\sum_{i=1}^{t-1} x_i = (t-1)\mu_{t-1}$ and manipulate algebraically:</p>
    
    <div class="formula-box">
      $$ \mu_t = \frac{\sum_{i=1}^t x_i}{t} = \frac{(\sum_{i=1}^{t-1} x_i) + x_t}{t} = \frac{(t-1)\mu_{t-1} + x_t}{t} $$
      $$ \mu_t = \frac{t \cdot \mu_{t-1} - \mu_{t-1} + x_t}{t} = \mu_{t-1} + \frac{x_t - \mu_{t-1}}{t} $$
    </div>
    <p>This is the recurrence relationship: the new mean is the old mean plus a correction term.</p>

    <h4>▶ 3.2 Recursive Formula for Variance (Welford)</h4>
    <p>For variance, we use Welford's Algorithm, which is numerically stable. Instead of tracking the variance, we track $M_{2,t}$, the sum of squared differences from the *current* mean: $M_{2,t} = \sum_{i=1}^t (x_i - \mu_t)^2$.</p>
    <p>The "simple proof" of the recurrence relationship for $M_2$ (omitting the complex algebraic steps) reduces to:</p>
    <div class="formula-box">
      $$ M_{2,t} = M_{2,t-1} + (x_t - \mu_{t-1}) \cdot (x_t - \mu_t) $$
    </div>
    <p>The population variance (divided by $n$) is then simply $Var_t = M_{2,t} / t$.
    Note that this formula only requires the previous values ($M_{2,t-1}$, $\mu_{t-1}$), the new value ($x_t$), and the just-calculated new mean ($\mu_t$). This avoids catastrophic cancellation.</p>
    
    <!-- SEZIONE 4: IMPLEMENTAZIONE (ex-Sezione 3) -->
    <h3>&gt; Section 4: Online Algorithm Implementation</h3>
    
    <h4>▶ 4.1 Incremental Algorithm (Python)</h4>
    <p>We implement a Python class that maintains the state ($n$, $mean$, $M2$) and implements the recursive relationships derived above.</p>
    
    <div class="sql-box">
<span class="sql-keyword">class</span> <span class="sql-class">IncrementalStatistics</span>:
    <span class="sql-keyword">def</span> <span class="sql-method">__init__</span>(<span class="sql-keyword">self</span>):
        <span class="sql-keyword">self</span>.n = <span class="sql-number">0</span>
        <span class="sql-keyword">self</span>.mean = <span class="sql-number">0.0</span>
        <span class="sql-comment"># M2 is the sum of squared differences from the mean</span>
        <span class="sql-keyword">self</span>.M2 = <span class="sql-number">0.0</span> 

    <span class="sql-keyword">def</span> <span class="sql-method">update</span>(<span class="sql-keyword">self</span>, new_data):
        <span class="sql-keyword">self</span>.n += <span class="sql-number">1</span>
        
        <span class="sql-comment"># Save the old mean for the variance calculation</span>
        old_mean = <span class="sql-keyword">self</span>.mean 
        
        <span class="sql-comment"># Update the mean (Formula 3.1)</span>
        delta = new_data - old_mean
        <span class="sql-keyword">self</span>.mean += delta / <span class="sql-keyword">self</span>.n
        
        <span class="sql-comment"># Update M2 (Formula 3.2)</span>
        delta2 = new_data - <span class="sql-keyword">self</span>.mean
        <span class="sql-keyword">self</span>.M2 += delta * delta2

    <span class="sql-keyword">def</span> <span class="sql-method">get_mean</span>(<span class="sql-keyword">self</span>):
        <span class="sql-keyword">return</span> <span class="sql-keyword">self</span>.mean

    <span class="sql-keyword">def</span> <span class="sql-method">get_variance</span>(<span class="sql-keyword">self</span>):
        <span class="sql-keyword">if</span> <span class="sql-keyword">self</span>.n < <span class="sql-number">2</span>:
            <span class="sql-keyword">return</span> <span class="sql-number">0.0</span>
        <span class="sql-keyword">return</span> <span class="sql-keyword">self</span>.M2 / <span class="sql-keyword">self</span>.n <span class="sql-comment"># Population variance</span>
  </div>

    <!-- SEZIONE 5: TEST (ex-Sezione 4) -->
    <h3>&gt; Section 5: Interactive Simulation and Test</h3>
    <p>Press the button to test the implemented algorithm on the dataset <code>[2, 4, 6, 8, 10]</code>. The chart and terminal will show how the mean and variance are updated at each step, converging to their final values.</p>
    
    <button class="btn" id="runSimulation">&gt; Run Simulation()</button>
    <canvas id="simChart"></canvas>
    <pre id="simOutput"></pre>

    <!-- SEZIONE 6: CONCLUSIONI (ex-Sezione 5) -->
    <h3>&gt; Section 6: Conclusions</h3>
    
    <h4>▶ 6.1 Results Comparison</h4>
    <p>As shown by the simulation, the final values converge to <strong>Mean = 6.00</strong> and <strong>Variance = 8.00</strong>. A batch calculation with Numpy confirms this:</p>
    
    <div class="sql-box">
<span class="sql-keyword">import</span> numpy <span class="sql-keyword">as</span> np
data = [<span class="sql-number">2</span>, <span class="sql-number">4</span>, <span class="sql-number">6</span>, <span class="sql-number">8</span>, <span class="sql-number">10</span>]
<span class="sql-class">print</span>(<span class="sql-string">f"Batch Mean: {np.mean(data):.2f}"</span>)
<span class="sql-class">print</span>(<span class="sql-string">f"Batch Variance: {np.var(data):.2f}"</span>)
    </div>
    <p>The results are identical, confirming the correctness of our incremental implementation.</p>

    <h4>▶ 6.2 Confirmed Advantages</h4>
    <p>This analysis has demonstrated that the incremental (online) algorithm is not only correct, but superior to the batch approach as required by the assignment:</p>
    <ul>
      <!-- Usato <code> invece di $...$ -->
      <li><strong>Efficiency:</strong> The simulation performed 5 <code>O(1)</code> updates instead of recalculating over <code>N</code> elements.</li>
      <li><strong>Memory:</strong> The algorithm used only 3 variables (<code>n</code>, <code>mean</code>, <code>M2</code>), not the entire <code>data</code> array.</li>
      <li><strong>Stability:</strong> The use of Welford's algorithm (updating <code>M2</code>) avoided the numerical stability problems discussed in Section 2.</li>
    </ul>

    <!-- Pulsante "Return Home" (dallo script originale) -->

  </div>
  
    <script>
    // --- Global Chart Instance ---
    let simChart = null;

    // --- Theme Toggle ---
    const toggleBtn = document.getElementById('toggle');
    let cyberpunkMode = false;
    toggleBtn.onclick = () => {
      cyberpunkMode = !cyberpunkMode;
      document.body.classList.toggle('cyberpunk-mode', cyberpunkMode);
      
      toggleBtn.textContent = cyberpunkMode ? 'Matrix Mode' : 'Cyberpunk Mode';
      
      // Aggiorna il grafico per il nuovo tema
      if (simChart) {
          // Ridisegna il grafico con i nuovi colori
          // Nota: La funzione drawChart ora gestisce l'aggiornamento dei colori
          simChart = drawChart('simChart', simChart, simChart.data);
      }
    };

    // --- DOM Elements ---
    const simOutput = document.getElementById('simOutput');
    
    // --- Utility Functions ---
    
    // Promise-based Typewriter
    function typeWriter(el, text, append = false, speed = 10) {
      return new Promise((resolve) => {
        let i = 0;
        const existingText = append ? el.textContent : '';
        if (append && existingText.length > 0) {
            el.textContent = existingText;
        } else {
            el.textContent = '';
        }
        
        const interval = setInterval(() => {
          if (i >= text.length) {
            clearInterval(interval);
            return resolve();
          }
          el.textContent = existingText + text.slice(0, i + 1);
          i++;
        }, speed);
      });
    }

    // Pause helper
    function pause(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * Creates or updates a Chart.js chart
     */
    function drawChart(canvasId, existingChart, chartData, type = 'line') {
      const ctx = document.getElementById(canvasId).getContext('2d');
      
      // Get current theme colors
      const styles = getComputedStyle(document.body);
      const accent = styles.getPropertyValue('--accent');
      const accent2 = styles.getPropertyValue('--accent-2');
      const accentDim = styles.getPropertyValue('--accent-dim');
      const text = styles.getPropertyValue('--text');

      if (existingChart) {
        // Aggiorna colori e dati
        existingChart.data = chartData;
        existingChart.options.plugins.legend.labels.color = text;
        existingChart.options.scales.y.grid.color = accentDim;
        existingChart.options.scales.y.ticks.color = text;
        existingChart.options.scales.x.grid.color = accentDim;
        existingChart.options.scales.x.ticks.color = text;
        
        const colors = [accent, accent2];
        chartData.datasets.forEach((dataset, i) => {
            dataset.backgroundColor = colors[i % colors.length] + '33';
            dataset.borderColor = colors[i % colors.length];
            dataset.borderWidth = 3;
            dataset.tension = 0.1;
            dataset.fill = true;
        });

        existingChart.update();
        return existingChart;
      }

      // Assign theme colors to datasets
      const colors = [accent, accent2];
      chartData.datasets.forEach((dataset, i) => {
        dataset.backgroundColor = dataset.backgroundColor || colors[i % colors.length] + '33'; // 33 for alpha fill
        dataset.borderColor = dataset.borderColor || colors[i % colors.length];
        dataset.borderWidth = dataset.borderWidth || 3;
        dataset.tension = 0.1; // Make the line chart smooth
        dataset.fill = true;
      });

      const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            labels: {
              color: text,
              font: { family: "'Cascadia Code', monospace", size: 14 }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            grid: { color: accentDim },
            ticks: { color: text, font: { family: "'Cascadia Code', monospace" } }
          },
          x: {
            grid: { color: accentDim },
            ticks: { color: text, font: { family: "'Cascadia Code', monospace" } }
          }
        }
      };

      return new Chart(ctx, {
        type: type,
        data: chartData,
        options: chartOptions
      });
    }

    // --- Simulazione Click Handler ---
    document.getElementById('runSimulation').onclick = async (e) => {
      const btn = e.target;
      btn.disabled = true;
      
      const data = [2, 4, 6, 8, 10];
      
      // Variabili per l'algoritmo
      let n = 0;
      let mean = 0.0;
      let M2 = 0.0;
      
      // Dati per il grafico
      let chartLabels = ['N=0'];
      let meanData = [0];
      let varianceData = [0];

      await typeWriter(simOutput, ">> Initializing simulation...\n", false, 5);
      
      // Grafico iniziale
      let chartData = {
        labels: chartLabels,
        datasets: [
          { label: 'Mean', data: meanData },
          { label: 'Variance', data: varianceData }
        ]
      };
      simChart = drawChart('simChart', simChart, chartData);
      
      await pause(500);
      
      for (let i = 0; i < data.length; i++) {
        const x = data[i];
        
        // --- Logica Algoritmo ---
        n += 1;
        let delta = x - mean;
        let old_mean = mean; // Salva la vecchia media
        mean += delta / n;
        let delta2 = x - mean;
        M2 += delta * delta2; // Questa è (x_t - old_mean) * (x_t - new_mean)
        let variance = (n < 2) ? 0.0 : M2 / n;
        // --- Fine Logica ---

        await typeWriter(simOutput, `\n>> Step ${n} (Data = ${x})\n`, true, 5);
        await pause(200);
        await typeWriter(simOutput, `   - Mean       = ${mean.toFixed(2)}\n`, true, 5);
        await typeWriter(simOutput, `   - Variance   = ${variance.toFixed(2)}\n`, true, 5);
        
        // Aggiorna dati grafico
        chartLabels.push(`N=${n}`);
        meanData.push(mean);
        varianceData.push(variance);
        
        // Aggiorna grafico
        simChart = drawChart('simChart', simChart, chartData);
        
        await pause(800);
      }
      
      await typeWriter(simOutput, "\n>> Simulation complete.\n", true, 5);
      await pause(200);
      await typeWriter(simOutput, ">> Comparison with Batch (Numpy):\n", true, 5);
      await typeWriter(simOutput, "   - Batch Mean: 6.00\n", true, 5);
      await typeWriter(simOutput, "   - Batch Variance: 8.00\n", true, 5);
      await typeWriter(simOutput, ">> Results match!", true, 5);
      
      btn.disabled = false;
    };

    // --- Pulsante "Return Home" ---
    const returnBtn = document.createElement('button');
    returnBtn.className = 'btn';
    returnBtn.id = 'backHome';
    returnBtn.textContent = '> return Home';
    returnBtn.style.marginTop = '2.5rem';

    const container = document.querySelector('.container');
    if (container) {
      container.appendChild(returnBtn);
      
      document.getElementById('backHome').addEventListener('click', () => {
        window.location.href = './index.html'; // Assumendo che esista
      });
    }

  </script>
</body>
</html>