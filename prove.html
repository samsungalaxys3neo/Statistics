<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Homework_5</title>
  <link href="https://fonts.cdnfonts.com/css/cascadia-code" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- MathJax for rendering LaTeX formulas -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  <style>
    :root {
      --bg: #0a0010;
      --accent: #b6ffb6;
      --accent-dim: rgba(182,255,182,.25);
      --accent-2: #ff8c00; /* A second accent for charts */
      --glow: #b6ffb6;
      --text: #f4fff7;
      --subtitle: #8aff8a;
      --code-bg: #171717;
      --container-bg: rgba(0,0,0,0.85);
    }
    
    body.cyberpunk-mode {
      --bg: #000;
      --accent: #ff00cc;
      --accent-dim: rgba(255,0,204,.25);
      --accent-2: #00f0ff; /* Cyberpunk secondary accent */
      --glow: #ff00cc;
      --text: #eaffef;
      --subtitle: #ff88ff;
      --code-bg: #1a001a;
      --container-bg: rgba(10, 0, 20, 0.85);
    }
    
    *{margin:0;padding:0;box-sizing:border-box}
    
    body{
      background:var(--bg);
      color:var(--text);
      font-family:'Cascadia Code', monospace;
      padding:2rem;
      transition:background .6s ease, color .6s ease;
    }
    
    /* Style for MathJax output */
    mjx-container {
      color: var(--text);
      margin: 1rem 0;
      text-align: center;
    }
    
    #toggle{position:fixed;top:16px;right:16px;padding:.55rem 1rem;border:none;border-radius:10px;cursor:pointer;background:linear-gradient(145deg,var(--accent),var(--glow));color:#000;font-weight:bold;box-shadow:0 0 12px var(--glow),inset 0 0 5px rgba(255,255,255,.2); z-index: 100;}
    #toggle:hover{transform:scale(1.05);box-shadow:0 0 18px var(--glow);}
    
    .container{max-width:900px;margin:6rem auto;padding:2rem 2.5rem;background:var(--container-bg);border:1px solid var(--accent-dim);border-radius:12px;box-shadow:0 0 20px var(--accent-dim), inset 0 0 10px rgba(255,255,255,0.05); transition: background .6s ease, border .6s ease;}
    
    h1,h2,h3,h4{color:var(--accent);text-shadow:0 0 8px var(--glow);text-align:center; transition: color .6s ease, text-shadow .6s ease;}
    h1{font-size:2.3rem;margin-bottom:.4rem;}
    h2{font-size:1.2rem;margin-bottom:2.5rem;opacity:.9;}
    h3{margin-top:2.5rem;margin-bottom:1.2rem;color:var(--subtitle); font-size: 1.4rem; border-bottom: 1px solid var(--accent-dim); padding-bottom: 0.5rem; text-align: left; transition: color .6s ease, border-bottom .6s ease;}
    h4{margin-top:1.5rem;margin-bottom:.5rem;font-size:1.1rem;color:var(--subtitle); text-align: left;}
    
    p{margin-bottom:1rem;line-height:1.7; opacity: 0.9;}
    p strong { color: var(--subtitle); font-weight: bold; }
    
    .formula-box{background:var(--code-bg);color:var(--text);border:1px solid var(--accent-dim);border-radius:10px;padding: 0.5rem 1.2rem;font-family:'Cascadia Code',monospace;overflow-x:auto;margin-top:1rem;margin-bottom:1.5rem;font-size:1.1rem;text-align:center;line-height:1.8; box-shadow: inset 0 0 8px rgba(0,0,0,0.3); transition: background .6s ease, border .6s ease;}
    
    #statsOutput, #dispersionOutput, #histogramOutput {
      background:rgba(0,0,0,0.8);
      padding: 1.5rem;
      border-radius:10px;
      font-family:'Cascadia Code',monospace;
      font-size:0.95rem;
      line-height:1.7;
      color:var(--accent);
      box-shadow:0 0 15px var(--accent-dim),inset 0 0 10px rgba(255,255,255,0.05);
      white-space:pre-wrap;
      word-wrap: break-word;
      min-height:150px;
      overflow-wrap:break-word;
      transition: color .6s ease, box-shadow .6s ease;
    }
    
    canvas{
      display:block;
      margin:2rem auto;
      background:rgba(0,0,0,0.8);
      border-radius:10px;
      box-shadow:0 0 20px var(--accent-dim);
      width: 100% !important; /* Force Chart.js to be responsive */
      max-height: 400px;
    }
    
    .btn{
      display:block;
      margin:1.5rem auto 1rem auto;
      background:transparent;
      border:1px solid var(--accent-dim);
      color:var(--accent);
      padding:.7rem 1.2rem;
      border-radius:8px;
      cursor:pointer;
      font-size: 1rem;
      font-family: 'Cascadia Code', monospace;
      text-shadow:0 0 8px var(--glow);
      transition:.25s;
      box-shadow: 0 0 10px var(--accent-dim);
    }
    .btn:hover{background:var(--accent);color:#000; box-shadow: 0 0 20px var(--glow);}
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      color: var(--accent-dim);
      background: transparent;
      box-shadow: none;
    }
  </style>
</head>
<body>
  
  <button id="toggle">Cyberpunk Mode</button>
  
  <div class="container">
    <h1>Homework_5</h1>
    <h2>Descriptive Statistics: Measures of Location and Dispersion</h2>

    <h3>> Introduction: What is Descriptive Statistics?</h3>
    <p>Descriptive statistics is the first step in any data analysis. It's the process of using and analyzing statistics to summarize and describe a dataset. Instead of looking at thousands of rows of data, we can use a few key numbers and charts to understand its main characteristics.</p>
    <p>These summaries generally fall into two categories:</p>
    <ul>
      <li><strong>Measures of Location (or Central Tendency):</strong> These tell us where the "center" or "typical" value of the data is (e.g., the average price).</li>
      <li><strong>Measures of Dispersion (or Variability):</strong> These tell us how "spread out" the data is (e.g., do all the prices cluster together, or are they all over the place?).</li>
    </ul>
    <p>This document will explore the most common measures for both, complete with interactive simulations.</p>

    <!-- =================================================================== -->
    <!-- SECTION 1: MEASURES OF LOCATION -->
    <!-- =================================================================== -->
    <h3>> Section 1 – Measures of Location (Central Tendency)</h3>
    <p>Measures of location describe the "typical" value of a dataset. They give us a single number that attempts to summarize the entire dataset's magnitude.</p>
    
    <h4>▶ Arithmetic Mean</h4>
    <p>The <strong>Mean</strong> (or average) is the most common measure. It's calculated by summing all values and dividing by the count of values. It's like the "center of gravity" for the data.</p>
    <div class="formula-box">$$\bar{x} = \frac{1}{N} \sum_{i=1}^{N} x_i = \frac{x_1 + x_2 + \cdots + x_N}{N}$$</div>
    <p><strong>Practical Use:</strong> Calculating an average test score, average monthly expense, or average user rating.</p>
    <p><strong>Limitations:</strong> Its main weakness is its high sensitivity to <strong>outliers</strong> (extreme values). A single, massive value can pull the mean significantly, making it misrepresent the "typical" value. Because of this, it is <strong>not a robust measure</strong>.</p>

    <h4>▶ Median</h4>
    <p>The <strong>Median</strong> is the "middle" value of a dataset that has been sorted. It is the 50th percentile, splitting the data exactly in half (50% of values are above it, 50% are below).</p>
    <div class="formula-box">$$\text{Median} = \begin{cases} x_{(N+1)/2} & N \text{ odd} \\ (x_{N/2}+x_{N/2+1})/2 & N \text{ even} \end{cases}$$</div>
    <p><strong>Practical Use:</strong> Reporting median household income or median home price. In these cases, a few billionaires or mansions would skew the mean, but the median gives a much better picture of the typical person.</p>
    <p><strong>Robustness:</strong> The median is a <strong>highly robust</strong> measure. It does not care about the *magnitude* of outliers, only their *position*. Whether the highest value is 100 or 100,000,000, it doesn't change the median. Run the simulation below to see this in action!</p>

    <h4>▶ Mode</h4>
    <p>The <strong>Mode</strong> is simply the most frequently occurring value in the dataset. A dataset can have one mode (unimodal), two modes (bimodal), or many modes (multimodal).</p>
    <p><strong>Practical Use:</strong> Best for <strong>categorical data</strong>. For example, finding the most popular T-shirt size (S, M, L, XL), the most common reason for a customer support call, or the most frequent "yes/no" answer.</p>
    <p><strong>Limitations:</strong> Less useful for continuous data (e.g., height in cm) where any specific value is unlikely to repeat. Can be misleading if the most "frequent" value is still very rare.</p>

    <h4>▶ Weighted Mean</h4>
    <p>A variation of the mean where some data points contribute more than others. Each value $x_i$ is multiplied by a "weight" $w_i$, and the sum is divided by the sum of the weights.</p>
    <div class="formula-box">$$ \bar{x}_w = \frac{\sum_{i=1}^{N} w_i x_i}{\sum_{i=1}^{N} w_i} $$</div>
    <p><strong>Practical Use:</strong> Calculating your final grade in a course (where exams are "weighted" more than homework), or finding the average price of a product from different suppliers with different market shares.</p>

    <h4>▶ Geometric Mean</h4>
    <p>The N-th root of the product of N numbers. It is most appropriate for sets of positive numbers that are interpreted multiplicatively (e.g., growth rates).</p>
    <div class="formula-box">$$ G = \sqrt[N]{x_1 x_2 \cdots x_N} $$</div>
    <p><strong>Practical Use:</strong> Calculating average investment returns over several years or average growth rates. If you have +50% growth one year (x1.5) and -50% the next (x0.5), the arithmetic mean is misleading, but the geometric mean gives the correct average growth.</p>

    <button class="btn" id="runSimulation">Run Central Tendency Simulation</button>
    <canvas id="centralTendencyChart"></canvas>
    <pre id="statsOutput"></pre>

    <!-- =================================================================== -->
    <!-- SECTION 2: MEASURES OF DISPERSION -->
    <!-- =================================================================== -->
    <h3>> Section 2 – Measures of Dispersion</h3>
    <p>Dispersion measures how "spread out" the data is. A low dispersion means the data points are clustered tightly around the center. A high dispersion means they are spread far apart.</p>
    
    <h4>▶ Range</h4>
    <p>The simplest measure of dispersion. It's the difference between the maximum and minimum value in the dataset.</p>
    <div class="formula-box">$$ \text{Range} = x_{\text{max}} - x_{\text{min}} $$</div>
    <p><strong>Practical Use:</strong> A quick, easy-to-understand check. "The test scores ranged from 65 to 98."</p>
    <p><strong>Limitations:</strong> Extremely sensitive to outliers. It is the least robust measure of dispersion as it *only* uses the two most extreme values.</p>

    <h4>▶ Variance</h4>
    <p>The <strong>Variance</strong> is the average of the squared differences from the Mean. It measures how far each number in the set is from the average, and thus, from every other number in the set.</p>
    <div class="formula-box">$$\sigma^2 = \frac{1}{N} \sum_{i=1}^{N} (x_i - \bar{x})^2$$</div>
    <p><strong>Limitations:</strong> Because it *squares* the differences, it's not in the same unit as the original data (e.g., if your data is in "meters", the variance is in "meters-squared"). This makes it hard to interpret. Like the mean, it is very sensitive to outliers.</p>

    <h4>▶ Standard Deviation</h4>
    <p>The <strong>Standard Deviation (SD)</strong> is the most common and useful measure of dispersion. It is simply the square root of the variance. This elegantly solves the unit problem!</p>
    <div class="formula-box">$$\sigma = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (x_i - \bar{x})^2}$$</div>
    <p><strong>Practical Use:</strong> A low SD means data is clustered around the mean. A high SD means it's spread out. It's used everywhere: in finance to measure volatility (risk), in science to measure the error of a measurement, and in manufacturing for quality control.</p>
    <p><strong>Limitations:</strong> Because it is based on the mean, it is also <strong>not robust</strong> and is heavily influenced by outliers.</p>

    <h4>▶ Interquartile Range (IQR)</h4>
    <p>The <strong>IQR</strong> is the dispersion equivalent of the median. It is the range of the "middle 50%" of the data. It's calculated as the difference between the 75th percentile (Q3) and the 25th percentile (Q1).</p>
    <div class="formula-box">$$IQR = Q_3 - Q_1$$</div>
    <p><strong>Practical Use:</strong> It is the key component of a <strong>box plot</strong>. It's used to understand the spread of data in fields like finance and medicine, where outliers are common. It's also used to *define* outliers (a common rule is: any point more than $1.5 \times IQR$ below Q1 or above Q3 is an outlier).</p>
    <p><strong>Robustness:</strong> Just as the median is a robust measure of location, the IQR is a <strong>highly robust measure of dispersion</strong>. It completely ignores the most extreme values, focusing only on the spread of the central bulk of the data. The simulation will show this clearly.</p>

    <h4>▶ Mean Absolute Deviation (MAD)</h4>
    <p>An alternative to standard deviation. Instead of squaring the differences (which amplifies outliers), MAD just takes the average of the *absolute* differences from the mean.</p>
    <div class="formula-box">$$ \text{MAD} = \frac{1}{N} \sum_{i=1}^{N} |x_i - \bar{x}| $$</div>
    <p><strong>Practical Use:</strong> Used in forecasting and other fields where a simple, interpretable measure of spread is needed that is less sensitive to outliers than the standard deviation.</p>

    <button class="btn" id="runDispersionDemo">Run Dispersion Demo</button>
    <canvas id="dispersionChart"></canvas>
    <pre id="dispersionOutput"></pre>

    <!-- =================================================================== -->
    <!-- SECTION 3: HISTOGRAM -->
    <!-- =================================================================== -->
    <h3>> Section 3 – Histogram Visualization</h3>
    <p>A histogram is a graphical representation of the data's <strong>frequency distribution</strong>. It groups numbers into ranges (called "bins") and shows how many data points fall into each bin. It's a powerful way to visualize the *shape* of your data (e.g., is it symmetric? Bimodal? Skewed?).</p>
    <p>Click the button below to generate a new set of random data and visualize its histogram.</p>
    <button class="btn" id="runHistogram">Generate Histogram</button>
    <canvas id="histogramChart"></canvas>
    <pre id="histogramOutput"></pre>
  </div>
  
  <script>
    // --- Global Chart Instances ---
    let centralChart = null;
    let dispersionChart = null;
    let histogramChart = null;

    // --- Theme Toggle ---
    const toggleBtn = document.getElementById('toggle');
    let cyberpunkMode = false;
    toggleBtn.onclick = () => {
      cyberpunkMode = !cyberpunkMode;
      document.body.classList.toggle('cyberpunk-mode', cyberpunkMode);
      
      // Update button text
      toggleBtn.textContent = cyberpunkMode ? 'Matrix Mode' : 'Cyberpunk Mode';
      
      // Update charts to reflect new theme
      // We must re-draw them, as Chart.js doesn't auto-update all theme colors
      if (centralChart) centralChart.update();
      if (dispersionChart) dispersionChart.update();
      if (histogramChart) histogramChart.update();
    };

    // --- DOM Elements ---
    const statsOutput = document.getElementById('statsOutput');
    const dispersionOutput = document.getElementById('dispersionOutput');
    const histogramOutput = document.getElementById('histogramOutput');
    
    // --- Utility Functions ---
    
    // Promise-based Typewriter for "terminal" simulation
    function typeWriter(el, text, append = false, speed = 10) {
      return new Promise((resolve) => {
        let i = 0;
        const existingText = append ? el.textContent : '';
        if (append && existingText.length > 0) {
            el.textContent = existingText;
        } else {
            el.textContent = '';
        }
        
        const interval = setInterval(() => {
          const char = text[i];
          if (char === '\n') {
            // Add a slight pause for newlines to feel more natural
            setTimeout(() => {}, 50);
          }
          el.textContent = existingText + text.slice(0, i + 1);
          i++;
          
          if (i >= text.length) {
            clearInterval(interval);
            resolve();
          }
        }, speed);
      });
    }

    // Pause helper
    function pause(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // --- Statistics Calculations ---
    function calculateMean(d) { return d.reduce((a, b) => a + b, 0) / d.length; }
    
    function calculateMedian(d) {
      const s = [...d].sort((a, b) => a - b);
      const m = Math.floor(s.length / 2);
      return s.length % 2 ? s[m] : (s[m - 1] + s[m]) / 2;
    }
    
    function calculateStdDev(d, m) {
      const v = d.reduce((a, b) => a + Math.pow(b - m, 2), 0) / d.length;
      return Math.sqrt(v);
    }
    
    function calculateQuartiles(d) {
      const s = [...d].sort((a, b) => a - b);
      const q = (p) => {
        const pos = (s.length - 1) * p;
        const base = Math.floor(pos);
        const rest = pos - base;
        return s[base + 1] ? s[base] + rest * (s[base + 1] - s[base]) : s[base];
      };
      return { q1: q(0.25), q3: q(0.75) };
    }
    
    function calculateIQR(d) {
      const { q1, q3 } = calculateQuartiles(d);
      return q3 - q1;
    }

    // --- Charting Function ---
    
    /**
     * Creates or updates a Chart.js chart, making it theme-aware.
     * @param {string} canvasId - The ID of the canvas element.
     * @param {Chart} existingChart - The existing Chart.js instance (or null).
     * @param {object} chartData - The data object for Chart.js ({ labels, datasets }).
     * @param {string} type - The chart type (e.g., 'bar', 'line').
     * @returns {Chart} The new or updated chart instance.
     */
    function drawChart(canvasId, existingChart, chartData, type = 'bar') {
      const ctx = document.getElementById(canvasId).getContext('2d');
      
      // Destroy the old chart if it exists
      if (existingChart) {
        existingChart.destroy();
      }

      // Get current theme colors from CSS variables
      const styles = getComputedStyle(document.body);
      const accent = styles.getPropertyValue('--accent');
      const accent2 = styles.getPropertyValue('--accent-2');
      const accentDim = styles.getPropertyValue('--accent-dim');
      const text = styles.getPropertyValue('--text');

      // Assign theme colors to datasets
      const colors = [accent, accent2];
      chartData.datasets.forEach((dataset, i) => {
        dataset.backgroundColor = dataset.backgroundColor || colors[i % colors.length] + '99'; // 99 for alpha
        dataset.borderColor = dataset.borderColor || colors[i % colors.length];
        dataset.borderWidth = dataset.borderWidth || 2;
        dataset.borderRadius = dataset.borderRadius || 6;
      });

      const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            labels: {
              color: text,
              font: { family: "'Cascadia Code', monospace", size: 14 }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            grid: {
              color: accentDim
            },
            ticks: {
              color: text,
              font: { family: "'Cascadia Code', monospace" }
            }
          },
          x: {
            grid: {
              color: accentDim
            },
            ticks: {
              color: text,
              font: { family: "'Cascadia Code', monospace" }
            }
          }
        }
      };

      return new Chart(ctx, {
        type: type,
        data: chartData,
        options: chartOptions
      });
    }

    // --- Simulation Click Handlers ---

    // -- Central Tendency Simulation --
    document.getElementById('runSimulation').onclick = async (e) => {
      e.target.disabled = true;
      const base = [20, 22, 25, 28, 30, 32, 26, 27];
      const outlier = 250;
      const out = [...base, outlier];
      
      const meanBase = calculateMean(base);
      const medianBase = calculateMedian(base);
      const meanOut = calculateMean(out);
      const medianOut = calculateMedian(out);

      const data = {
        labels: ['Mean', 'Median'],
        datasets: [
          { label: 'Base Dataset', data: [meanBase, medianBase] },
          { label: 'With Outlier', data: [meanOut, medianOut] }
        ]
      };
      
      await typeWriter(statsOutput, ">> Initializing simulation...\n", false, 5);
      await pause(200);
      await typeWriter(statsOutput, `>> Base Dataset:\n   [${base.join(', ')}]\n\n`, true, 5);
      await pause(300);
      await typeWriter(statsOutput, ">> Calculating location...\n", true, 5);
      await pause(500);
      await typeWriter(statsOutput, `   - Arithmetic Mean: ${meanBase.toFixed(2)}\n   - Median:          ${medianBase.toFixed(2)}\n\n`, true, 5);

      // Draw initial chart
      centralChart = drawChart('centralTendencyChart', centralChart, data);
      
      await pause(1000);
      await typeWriter(statsOutput, `>> Adding Extreme Outlier: ${outlier}\n`, true, 5);
      await pause(500);
      await typeWriter(statsOutput, ">> Recalculating...\n", true, 5);
      await pause(500);
      
      let meanDiff = meanOut - meanBase;
      let medianDiff = medianOut - medianBase;
      
      await typeWriter(statsOutput, `   - Arithmetic Mean: ${meanOut.toFixed(2)} (Jumped by ${meanDiff.toFixed(2)}!)\n   - Median:          ${medianOut.toFixed(2)} (Only moved by ${medianDiff.toFixed(2)}!)\n\n`, true, 5);
      await pause(200);
      await typeWriter(statsOutput, ">> CONCLUSION: The Mean is heavily affected by the outlier.\n>> The Median is ROBUST.", true, 5);
      
      e.target.disabled = false;
    };

    // -- Dispersion Simulation --
    document.getElementById('runDispersionDemo').onclick = async (e) => {
      e.target.disabled = true;
      const base = [20, 22, 25, 28, 30, 32, 26, 27];
      const outlier = 250;
      const out = [...base, outlier];
      
      const meanB = calculateMean(base), stdB = calculateStdDev(base, meanB), iqrB = calculateIQR(base);
      const meanO = calculateMean(out), stdO = calculateStdDev(out, meanO), iqrO = calculateIQR(out);

      const data = {
        labels: ['Std. Deviation', 'IQR'],
        datasets: [
          { label: 'Base Dataset', data: [stdB, iqrB] },
          { label: 'With Outlier', data: [stdO, iqrO] }
        ]
      };
      
      await typeWriter(dispersionOutput, ">> Initializing simulation...\n", false, 5);
      await pause(200);
      await typeWriter(dispersionOutput, `>> Base Dataset:\n   [${base.join(', ')}]\n\n`, true, 5);
      await pause(300);
      await typeWriter(dispersionOutput, ">> Calculating dispersion...\n", true, 5);
      await pause(500);
      await typeWriter(dispersionOutput, `   - Std. Deviation: ${stdB.toFixed(2)}\n   - IQR:              ${iqrB.toFixed(2)}\n\n`, true, 5);

      // Draw initial chart
      dispersionChart = drawChart('dispersionChart', dispersionChart, data);
      
      await pause(1000);
      await typeWriter(dispersionOutput, `>> Adding Extreme Outlier: ${outlier}\n`, true, 5);
      await pause(500);
      await typeWriter(dispersionOutput, ">> Recalculating...\n", true, 5);
      await pause(500);
      
      await typeWriter(dispersionOutput, `   - Std. Deviation: ${stdO.toFixed(2)} (Massively affected!)\n   - IQR:              ${iqrO.toFixed(2)} (Barely changed!)\n\n`, true, 5);
      await pause(200);
      await typeWriter(dispersionOutput, ">> CONCLUSION: Std. Deviation, like the Mean, is not robust.\n>> The IQR is a ROBUST measure of spread.", true, 5);
      
      e.target.disabled = false;
    };
    
    // -- Histogram Simulation --
    document.getElementById('runHistogram').onclick = async (e) => {
      e.target.disabled = true;
      
      // Generate some random data (e.g., 200 values, slightly normal-ish)
      const data = Array.from({length: 200}, () => Math.floor(Math.random() * 50) + Math.floor(Math.random() * 51));
      
      const bins = ['0-19', '20-39', '40-59', '60-79', '80-100'];
      const counts = [0, 0, 0, 0, 0];
      
      data.forEach(v => {
        if (v < 20) counts[0]++;
        else if (v < 40) counts[1]++;
        else if (v < 60) counts[2]++;
        else if (v < 80) counts[3]++;
        else counts[4]++;
      });

      const chartData = {
        labels: bins,
        datasets: [{ label: 'Frequency', data: counts }]
      };
      
      await typeWriter(histogramOutput, `>> Generating 200 random data points...\n`, false, 5);
      await pause(500);
      await typeWriter(histogramOutput, `>> Sample: [${data.slice(0, 10).join(', ')}, ...]\n\n`, true, 5);
      await pause(300);
      await typeWriter(histogramOutput, ">> Tallying data into bins...\n", true, 5);
      await pause(500);
      
      let binText = "";
      bins.forEach((bin, i) => {
        binText += `   - Bin ${bin}: ${counts[i]} values\n`;
      });
      await typeWriter(histogramOutput, binText + "\n", true, 5);
      await pause(200);
      
      // Draw histogram
      histogramChart = drawChart('histogramChart', histogramChart, chartData, 'bar');
      await typeWriter(histogramOutput, ">> Rendering histogram.", true, 5);
      
      e.target.disabled = false;
    };

  </script>
</body>
</html>