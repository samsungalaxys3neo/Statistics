<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Homework 11 | Brownian Motion</title>
  
  <!-- Font -->
  <link href="https://fonts.cdnfonts.com/css/cascadia-code" rel="stylesheet">
  
  <!-- MathJax Configuration for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: {
        fontCache: 'global'
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    /* --- STYLING & AESTHETICS --- */
    :root {
      --bg: #0a0010;
      --accent: #b6ffb6;
      --accent-dim: rgba(182,255,182,.2);
      --glow: #b6ffb6;
      --text: #f4fff7;
      --subtitle: #8aff8a;
      --grid: rgba(182,255,182,0.08);
      --container-bg: rgba(0,0,0,0.85);
      --border-radius: 12px;
    }
    body.cyberpunk-mode {
      --bg: #050005;
      --accent: #ff00cc;
      --accent-dim: rgba(255,0,204,.2);
      --glow: #ff00cc;
      --text: #eaffef;
      --subtitle: #ff88ff;
      --grid: rgba(255,0,204,0.1);
    }

    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      background:var(--bg);
      color:var(--text);
      font-family:'Cascadia Code', monospace;
      overflow-x:hidden;
      padding:2rem;
      transition:background .6s ease, color .6s ease;
      line-height: 1.6;
    }

    #toggle{
      position:fixed;top:20px;right:20px;z-index:100;
      background:linear-gradient(135deg,var(--accent),var(--glow));
      color:#000;border:none;
      padding:.6rem 1.2rem;border-radius:30px;cursor:pointer;
      font-weight:bold;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
      box-shadow:0 0 15px var(--glow),inset 0 0 5px rgba(255,255,255,.3);
      transition:transform .3s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow .3s;
    }
    #toggle:hover{transform:scale(1.05);box-shadow:0 0 25px var(--glow);}

    .container{
      max-width:900px;
      margin:5rem auto 8rem auto; /* More bottom margin */
      padding:3rem 3.5rem; /* Increased padding */
      background: var(--container-bg);
      border:1px solid var(--accent-dim);
      border-radius: var(--border-radius);
      box-shadow:0 0 30px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,255,255,0.02);
      backdrop-filter: blur(5px);
    }
    
    h1,h2,h3,h4{color:var(--accent);text-shadow:0 0 10px var(--accent-dim);text-align:center;}
    
    h1{
      font-size:2.5rem;
      margin-bottom:0.5rem;
      letter-spacing: -1px;
    }
    h2{
      font-size:1.1rem;
      margin-bottom:3rem; /* More space after subtitle */
      opacity:.8;
      font-weight: normal;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    h3{
      margin-top:3rem; /* More space before sections */
      margin-bottom:1.5rem;
      color:var(--subtitle); 
      text-align: left; 
      border-bottom: 1px solid var(--accent-dim); 
      padding-bottom: 0.8rem;
      font-size: 1.3rem;
    }
    
    p{
      margin-bottom:1.5rem; 
      line-height: 1.8; /* Better readability */
      text-align: justify;
      color: rgba(255,255,255,0.9);
    }
    
    ul {
      margin-bottom: 1.5rem;
    }

    .sql-box{
      background:#0f0f0f;
      color:#e0e0e0;
      border: 1px solid var(--accent-dim);
      border-radius:8px;
      padding:1.5rem;
      font-family:'Cascadia Code', monospace;
      overflow-x:auto;
      margin: 2rem 0; /* More vertical space */
      box-shadow:inset 0 0 15px rgba(0,0,0,0.3);
      font-size: 0.9rem;
      line-height: 1.5;
    }
    .sql-keyword{color:#569cd6;font-weight:bold;} /* VS Code blue-ish */
    .sql-string{color:#ce9178;} /* VS Code orange-ish */
    .sql-number{color:#b5cea8;} /* VS Code green-ish */
    .js-comment{color:#6a9955; font-style: italic;}

    /* Simulation Controls */
    .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1.5rem;
        margin: 2.5rem 0;
        padding: 1.5rem;
        border: 1px dashed var(--accent-dim);
        border-radius: var(--border-radius);
        background: rgba(255,255,255,0.02);
    }
    .control-group {
        display: flex;
        flex-direction: column;
    }
    label {
        font-size: 0.8rem;
        color: var(--subtitle);
        margin-bottom: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    input[type="number"], select {
        background: #121212;
        border: 1px solid var(--accent-dim);
        color: var(--accent);
        padding: 0.8rem;
        border-radius: 6px;
        font-family: inherit;
        font-size: 1rem;
        transition: border-color 0.3s, box-shadow 0.3s;
    }
    input[type="number"]:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 10px var(--accent-dim);
    }

    .btn{
      display:block;
      margin: 2rem auto;
      background:transparent;
      border:1px solid var(--accent);
      color:var(--accent);
      padding:0.8rem 2rem;
      border-radius:8px;
      cursor:pointer;
      text-shadow:0 0 5px var(--glow);
      transition:all .3s ease;
      width: 100%;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 1rem;
    }
    .btn:hover{
      background:var(--accent);
      color:#000;
      box-shadow: 0 0 20px var(--glow);
    }

    /* Canvas styling */
    canvas {
        display:block;
        margin: 2.5rem auto;
        background:#050505;
        border: 1px solid var(--accent-dim);
        border-radius: var(--border-radius);
        box-shadow:0 0 25px rgba(0,0,0,0.5);
        width:100%;
        height: 450px; /* Increased height */
    }

    /* Output console style */
    #outputStats {
      background: rgba(0, 0, 0, 0.9);
      padding: 1.5rem;
      border-radius: 8px;
      font-family: 'Cascadia Code', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--accent);
      border-left: 4px solid var(--accent);
      margin-top: 2rem;
      min-height: 80px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    /* Responsive */
    @media (max-width: 768px) {
      body { padding: 0.5rem; }
      .container { margin: 2rem auto; padding: 1.5rem; width: 98%; }
      h1 { font-size: 1.8rem; }
      canvas { height: 300px; }
      .controls { grid-template-columns: 1fr; gap: 1rem; }
    }
  </style>
</head>
<body>

<!-- Toggle Mode Button -->
<button id="toggle">Cyberpunk Mode</button>

<div class="container">
  
  <h1>Homework 11</h1>
  <h2>Stochastic Processes: Brownian Motion</h2>

  <h3>&gt; 1. Theoretical Framework</h3>
  <p>
    In our previous computational explorations, we analyzed the <em>Simple Random Walk</em> (SRW), a process defined by discrete time steps $\Delta t$ and discrete state transitions (e.g., $\pm 1$). 
    We subsequently examined the Poisson process, which introduced the concept of continuous time while maintaining discrete integer jumps (representing event arrivals).
  </p>
  <p>
    The <strong>Wiener Process</strong>, colloquially known as standard Brownian Motion $W_t$, represents the continuous limit of the Random Walk as time steps and jump sizes approach zero. It is a fundamental stochastic process characterized by the following rigorous properties:
  </p>
  <ul>
      <li style="margin-left: 20px; list-style-type: square; color: var(--subtitle); margin-bottom: 8px;">
        <strong>Initial Condition:</strong> $W_0 = 0$ almost surely.
      </li>
      <li style="margin-left: 20px; list-style-type: square; color: var(--subtitle); margin-bottom: 8px;">
        <strong>Independent Increments:</strong> The increment $W_{t+u} - W_t$ is statistically independent of the process history $W_s$ for all $s \le t$.
      </li>
      <li style="margin-left: 20px; list-style-type: square; color: var(--subtitle); margin-bottom: 8px;">
        <strong>Gaussian Increments:</strong> The change in value over a time interval $u$ is normally distributed with mean 0 and variance $u$: 
        $$ W_{t+u} - W_t \sim \mathcal{N}(0, u) $$
      </li>
      <li style="margin-left: 20px; list-style-type: square; color: var(--subtitle);">
        <strong>Continuity:</strong> The sample paths $t \to W_t$ are continuous almost surely, although they are nowhere differentiable (fractal nature).
      </li>
  </ul>

  <h3>&gt; 2. The Box-Muller Transform</h3>
  <p>
    Standard computational pseudo-random number generators (such as JavaScript's <code>Math.random()</code>) produce values uniformly distributed in the interval $(0, 1)$. To accurately simulate Brownian motion, we require normally distributed increments.
  </p>
  <p>
    The <strong>Box-Muller transform</strong> is an efficient algorithm that transforms two independent uniform samples, $U_1, U_2 \sim \mathcal{U}(0, 1)$, into two independent standard normal samples $Z_0, Z_1 \sim \mathcal{N}(0, 1)$ using the following polar coordinate transformations:
  </p>
  
  <p style="text-align: center; margin: 2rem 0;">
    $$ Z_0 = \sqrt{-2 \ln U_1} \cos(2\pi U_2) $$
    $$ Z_1 = \sqrt{-2 \ln U_1} \sin(2\pi U_2) $$
  </p>
  
  <p>
    In our discrete simulation approximation, we update the process state iteratively as follows:
    $$ W_{t+\Delta t} = W_t + \sigma \sqrt{\Delta t} \cdot Z $$
    where $\sigma$ represents the volatility parameter.
  </p>

  <h3>&gt; 3. Implementation Logic</h3>
  <div class="sql-box">
    <span class="js-comment">// Box-Muller Implementation in JavaScript</span><br>
    <span class="sql-keyword">function</span> boxMuller() {<br>
    &nbsp;&nbsp;<span class="sql-keyword">let</span> u1 = <span class="sql-number">0</span>, u2 = <span class="sql-number">0</span>;<br>
    &nbsp;&nbsp;<span class="js-comment">// Generate U1 in (0,1] to avoid log(0) singularity</span><br>
    &nbsp;&nbsp;<span class="sql-keyword">while</span>(u1 === <span class="sql-number">0</span>) u1 = Math.random();<br>
    &nbsp;&nbsp;u2 = Math.random();<br>
    <br>
    &nbsp;&nbsp;<span class="js-comment">// Apply Transformation</span><br>
    &nbsp;&nbsp;<span class="sql-keyword">return</span> Math.sqrt(<span class="sql-number">-2.0</span> * Math.log(u1)) * <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.cos(<span class="sql-number">2.0</span> * Math.PI * u2);<br>
    }
  </div>

  <h3>&gt; 4. Continuous Time Simulation</h3>
  
  <div class="controls">
      <div class="control-group">
          <label for="numPaths">Number of Paths (Sample Size)</label>
          <input type="number" id="numPaths" value="50" min="1" max="500">
      </div>
      <div class="control-group">
          <label for="numSteps">Time Steps (dt precision)</label>
          <input type="number" id="numSteps" value="1000" min="100" max="10000">
      </div>
      <div class="control-group">
          <label for="volatility">Volatility ($\sigma$)</label>
          <input type="number" id="volatility" value="1" step="0.1">
      </div>
  </div>

  <button class="btn" id="runSim">&gt; Run Simulation()</button>

  <canvas id="brownianCanvas"></canvas>
  <div id="outputStats">&gt; System Ready. Waiting for input...</div>

</div>

<script>
// --- PART 1: UI & Theming ---
const toggleBtn = document.getElementById('toggle');
let cyberpunkMode = false;
function setMode(isCyberpunk) {
  cyberpunkMode = isCyberpunk;
  document.body.classList.toggle('cyberpunk-mode', cyberpunkMode);
  toggleBtn.textContent = cyberpunkMode ? 'Matrix Mode' : 'Cyberpunk Mode';
  // Redraw if data exists to match new colors
  if (window.lastSimulationData) {
      drawBrownianPaths(window.lastSimulationData);
  }
}
setMode(false); 
toggleBtn.addEventListener('click', () => setMode(!cyberpunkMode));


// --- PART 2: Math Logic (Box-Muller) ---

/**
 * Generates a random number from a Standard Normal Distribution N(0,1)
 * utilizing the Box-Muller transform.
 */
function boxMullerRandom() {
    let u1 = 0, u2 = 0;
    while(u1 === 0) u1 = Math.random(); // Exclude 0
    u2 = Math.random();
    return Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
}

// --- PART 3: Simulation Core ---

const canvas = document.getElementById('brownianCanvas');
const ctx = canvas.getContext('2d');
const outputStats = document.getElementById('outputStats');
const runBtn = document.getElementById('runSim');

function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    if (window.lastSimulationData) {
        drawBrownianPaths(window.lastSimulationData);
    }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/**
 * Main Simulation Loop
 */
function runSimulation() {
    const numPaths = parseInt(document.getElementById('numPaths').value);
    const numSteps = parseInt(document.getElementById('numSteps').value);
    const sigma = parseFloat(document.getElementById('volatility').value);
    const T = 1.0; 
    const dt = T / numSteps;
    const sqrtDt = Math.sqrt(dt);

    const allPaths = [];
    let minW = 0;
    let maxW = 0;
    let finalValues = [];

    // Path Generation
    for (let p = 0; p < numPaths; p++) {
        const path = new Float32Array(numSteps + 1);
        path[0] = 0; // W_0 = 0
        
        for (let i = 1; i <= numSteps; i++) {
            // W_{t+1} = W_t + sigma * Z * sqrt(dt)
            const dW = sigma * boxMullerRandom() * sqrtDt;
            path[i] = path[i-1] + dW;
            
            // Track min/max for dynamic scaling
            if (path[i] < minW) minW = path[i];
            if (path[i] > maxW) maxW = path[i];
        }
        allPaths.push(path);
        finalValues.push(path[numSteps]);
    }

    const simulationData = { allPaths, minW, maxW, numSteps, numPaths };
    window.lastSimulationData = simulationData;
    
    drawBrownianPaths(simulationData);
    calculateStats(finalValues, T);
}

/**
 * Rendering Logic
 */
function drawBrownianPaths(data) {
    const { allPaths, minW, maxW, numSteps, numPaths } = data;
    
    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    ctx.clearRect(0, 0, width, height);

    const style = getComputedStyle(document.body);
    const accentColor = style.getPropertyValue('--accent').trim();
    const gridColor = style.getPropertyValue('--grid').trim() || 'rgba(255,255,255,0.1)';
    const textColor = style.getPropertyValue('--text').trim();

    const padTop = 30;
    const padBot = 30;
    const padLeft = 50;
    const plotHeight = height - padTop - padBot;
    const plotWidth = width - padLeft;

    const mapX = (i) => padLeft + (i / numSteps) * plotWidth;
    const rangeY = maxW - minW || 1;
    const mapY = (val) => (height - padBot) - ((val - minW) / rangeY) * plotHeight;

    // --- Grid & Axis ---
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    // Zero Line
    const zeroY = mapY(0);
    if (zeroY >= padTop && zeroY <= height - padBot) {
        ctx.strokeStyle = accentColor;
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = 1.5; // Slightly thicker zero line
        ctx.moveTo(padLeft, zeroY);
        ctx.lineTo(width, zeroY);
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.globalAlpha = 1.0;
    }
    
    // Y Axis
    ctx.beginPath();
    ctx.strokeStyle = textColor;
    ctx.globalAlpha = 0.5;
    ctx.moveTo(padLeft, padTop);
    ctx.lineTo(padLeft, height - padBot);
    ctx.stroke();
    ctx.globalAlpha = 1.0;

    // Labels
    ctx.fillStyle = textColor;
    ctx.font = "11px Cascadia Code";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    
    // Draw Max, Min, 0 labels
    ctx.fillText(maxW.toFixed(2), padLeft - 10, mapY(maxW));
    ctx.fillText(minW.toFixed(2), padLeft - 10, mapY(minW));
    if (Math.abs(zeroY - mapY(maxW)) > 20 && Math.abs(zeroY - mapY(minW)) > 20) {
        ctx.fillText("0.00", padLeft - 10, mapY(0));
    }

    // --- Paths ---
    ctx.lineWidth = 1.5;
    
    allPaths.forEach((path, idx) => {
        ctx.beginPath();
        ctx.strokeStyle = accentColor; 
        ctx.globalAlpha = 0.12; 

        if (idx === numPaths - 1) {
            ctx.globalAlpha = 1.0;
            ctx.lineWidth = 2.5;
            ctx.shadowBlur = 15;
            ctx.shadowColor = accentColor;
        } else {
            ctx.shadowBlur = 0;
            ctx.lineWidth = 1.5;
        }

        ctx.moveTo(mapX(0), mapY(path[0]));
        for (let i = 1; i <= numSteps; i++) {
            ctx.lineTo(mapX(i), mapY(path[i]));
        }
        ctx.stroke();
    });
    
    ctx.globalAlpha = 1.0;
    ctx.shadowBlur = 0;
}

function calculateStats(finals, T) {
    let sum = 0;
    let sumSq = 0;
    const n = finals.length;
    
    for(let val of finals) {
        sum += val;
        sumSq += val * val;
    }
    
    const mean = sum / n;
    const variance = (sumSq / n) - (mean * mean);
    
    const text = `> Statistical Analysis at time T=${T}:\n` +
                 `> Empirical Mean W(T) : ${mean.toFixed(5)} (Theoretical: 0)\n` +
                 `> Empirical Var       : ${variance.toFixed(5)} (Theoretical: T*sigma^2)\n` +
                 `> Generator           : Box-Muller Transform\n` +
                 `> Status              : Computation Complete.`;
                 
    typeWriter(outputStats, text, 5);
}

// --- PART 4: Utilities ---

function typeWriter(element, text, speed = 15) {
  if (!element) return;
  element.textContent = ''; 
  let i = 0;
  const cursor = document.createElement('span');
  cursor.textContent = 'â–ˆ';
  cursor.style.animation = "blink 1s step-end infinite";
  element.appendChild(cursor);

  // Simple blink animation
  if (!document.getElementById('cursor-style')) {
      const style = document.createElement('style');
      style.id = 'cursor-style';
      style.textContent = `@keyframes blink { 50% { opacity: 0; } }`;
      document.head.appendChild(style);
  }

  if(element.typingInterval) clearInterval(element.typingInterval);

  element.typingInterval = setInterval(() => {
    if (i < text.length) {
      element.textContent = text.substring(0, i + 1);
      element.appendChild(cursor);
      i++;
    } else {
      clearInterval(element.typingInterval);
    }
  }, speed);
}

// Return Home Button Logic (Modified for better spacing)
const returnBtn = document.createElement('button');
returnBtn.className = 'btn';
returnBtn.id = 'backHome';
returnBtn.textContent = '> return Home';
// Aumentato il margine superiore per renderlo "meno appiccicato"
returnBtn.style.marginTop = '4rem'; 
returnBtn.style.width = 'auto'; // Lasciamo che si adatti al contenuto
returnBtn.style.display = 'inline-block'; // O block a seconda della preferenza, qui lo centro
returnBtn.style.marginLeft = 'auto';
returnBtn.style.marginRight = 'auto';

const container = document.querySelector('.container');
if (container) {
  // Container wrapper for center alignment of the button
  const btnContainer = document.createElement('div');
  btnContainer.style.textAlign = 'center';
  btnContainer.appendChild(returnBtn);
  
  container.appendChild(btnContainer);
  
  document.getElementById('backHome').addEventListener('click', () => {
    window.location.href = './index.html'; 
  });
}

// Initial Run
runBtn.addEventListener('click', runSimulation);
setTimeout(runSimulation, 500);

</script>
</body>
</html>