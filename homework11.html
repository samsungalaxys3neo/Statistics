<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Homework 11 | Brownian Motion</title>
<link href="https://fonts.cdnfonts.com/css/cascadia-code" rel="stylesheet">

<!-- MathJax for LaTeX formulas -->
<script>
  window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
    svg: { fontCache: 'global' }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
  :root {
    /* Default: Matrix (verde) */
    --bg: #0a0010;
    --accent: #b6ffb6;
    --accent-dim: rgba(182,255,182,.25);
    --glow: #b6ffb6;
    --text: #f4fff7;
    --container-bg: rgba(0,0,0,0.85);
  }
  body.cyberpunk-mode {
    /* Cyberpunk (fucsia) */
    --bg: #000;
    --accent: #ff00cc;
    --accent-dim: rgba(255,0,204,.25);
    --glow: #ff00cc;
    --text: #eaffef;
  }

  *{margin:0;padding:0;box-sizing:border-box}
  html,body{height:100%}
  body{
    background:var(--bg);
    color:var(--text);
    font-family:'Cascadia Code', monospace;
    overflow-x:hidden;
    padding:2rem;
    transition:background .6s ease, color .6s ease;
  }

  #toggle{
    position:fixed;top:16px;right:16px;z-index:10;
    background:linear-gradient(145deg,var(--accent),var(--glow));
    color:#000;border:none;
    padding:.55rem 1rem;border-radius:10px;cursor:pointer;
    font-weight:bold;box-shadow:0 0 12px var(--glow),inset 0 0 5px rgba(255,255,255,.2);
    transition:transform .25s, box-shadow .25s;
  }
  #toggle:hover{transform:scale(1.05);box-shadow:0 0 18px var(--glow);}

  .container{
    max-width:850px;margin:6rem auto;padding:2rem 2.5rem;
    background:var(--container-bg);
    border:1px solid var(--accent-dim);
    border-radius:12px;
    box-shadow:0 0 20px var(--accent-dim), inset 0 0 10px rgba(255,255,255,0.05);
  }
  
  h1{font-size:2.3rem;text-align:center;color:var(--accent);text-shadow:0 0 12px var(--glow);letter-spacing:1px;margin-bottom:.5rem;}
  h2{font-size:1.05rem;text-align:center;color:var(--accent);opacity:.9;margin-bottom:4rem;}
  h3{text-align:center;color:var(--accent);opacity:.7;font-size:.95rem;margin-bottom:2.5rem;}
  
  .terminal-line{display:flex;align-items:flex-start;margin-bottom:1rem;line-height:1.65;}
  .terminal-line::before{content:">";color:var(--accent);text-shadow:0 0 10px var(--glow);margin-right:.75rem;flex-shrink:0;}
  .terminal-line p{margin:0; text-align: justify;}
  strong{color:var(--accent);text-shadow:0 0 6px var(--glow);}

  /* Stile speciale per i blocchi di codice/formule */
  .code-block {
    background: rgba(0,0,0,0.6);
    border-left: 3px solid var(--accent);
    padding: 1rem;
    margin: 1rem 0 2rem 1.5rem;
    font-size: 0.9rem;
    color: var(--text);
  }

  /* --- Simulation Area Styles --- */
  .detector-box{
    background:rgba(0,0,0,0.9);
    border:1px solid var(--accent-dim);
    border-radius:10px;
    padding:1.5rem;
    margin-top:2.5rem;
    box-shadow:0 0 18px var(--accent-dim), inset 0 0 8px rgba(255,255,255,0.05);
  }

  .controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
    margin-bottom: 1.5rem;
  }

  .control-group {
    display: flex;
    flex-direction: column;
  }
  
  label {
    font-size: 0.8rem;
    color: var(--accent);
    opacity: 0.8;
    margin-bottom: 0.4rem;
    text-transform: uppercase;
  }
  
  input[type="number"] {
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--accent-dim);
    color: var(--accent);
    padding: 0.6rem;
    border-radius: 6px;
    font-family: inherit;
    font-size: 1rem;
    width: 100%;
  }
  input[type="number"]:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 10px var(--accent-dim);
  }

  canvas {
    display: block;
    background: #050505;
    border: 1px solid var(--accent-dim);
    border-radius: 8px;
    width: 100%;
    height: 350px;
    margin-bottom: 1rem;
  }

  #terminalOutput {
    color: var(--accent);
    font-size: 0.85rem;
    line-height: 1.4;
    white-space: pre-wrap;
    min-height: 80px;
    padding: 0.5rem;
    border-top: 1px dashed var(--accent-dim);
    margin-top: 1rem;
  }

  .run-btn{
    display:block;margin:0 auto;background:transparent;border:1px solid var(--accent-dim);
    color:var(--accent);padding:.5rem 2rem;border-radius:8px;cursor:pointer;text-shadow:0 0 8px var(--glow);transition:.25s;
    font-family: inherit; font-weight: bold; text-transform: uppercase; width: 100%;
  }
  .run-btn:hover{background:var(--accent);color:#000;}

  /* --- Back Home Button --- */
  #backHome{
    display:block;margin:2.5rem auto 0;background:transparent;border:1px solid var(--accent-dim);
    color:var(--accent);cursor:pointer;padding:.6rem 1rem;border-radius:8px;
    font-family:'Cascadia Code', monospace;text-shadow:0 0 8px var(--glow);transition:.25s;
  }
  #backHome:hover{background:var(--accent);color:#000}

  /* Responsive */
  @media (max-width: 768px) {
    .container { margin: 3rem auto; padding: 1.5rem; width: 95%; }
    h1 { font-size: 1.8rem; }
    canvas { height: 250px; }
  }
</style>
</head>
<body>

<button id="toggle">Cyberpunk Mode</button>

<div class="container">
  <h1>Homework_11</h1>
  <h2>Stochastic Processes: Brownian Motion</h2>



  <div class="terminal-line">
    <p>The <strong>Wiener Process</strong> ($W_t$), or standard Brownian Motion, represents the continuous limit of the Random Walk. It is the mathematical foundation for modeling random continuous change.</p>
  </div>

  <div class="terminal-line">
    <p><strong>Key Properties:</strong></p>
  </div>
  <div class="code-block">
    1. Initial Condition: $W_0 = 0$<br>
    2. Independent Increments<br>
    3. Gaussian Increments: $W_{t+u} - W_t \sim \mathcal{N}(0, u)$<br>
    4. Continuous but nowhere differentiable paths
  </div>

  <div class="terminal-line">
    <p>To simulate this computationally, we use the <strong>Box-Muller Transform</strong> to generate normally distributed random numbers ($Z$) from uniform sources.</p>
  </div>

  <div class="terminal-line">
    <p><strong>The Update Rule:</strong></p>
  </div>
  <p style="text-align: center; margin-bottom: 2rem;">
    $$ W_{t+\Delta t} = W_t + \sigma \sqrt{\Delta t} \cdot Z $$
  </p>

  <div class="detector-box">
    <div class="controls">
      <div class="control-group">
          <label for="numPaths">Paths (N)</label>
          <input type="number" id="numPaths" value="50" min="1" max="200">
      </div>
      <div class="control-group">
          <label for="numSteps">Steps (T)</label>
          <input type="number" id="numSteps" value="1000" min="100" max="5000">
      </div>
      <div class="control-group">
          <label for="volatility">Volatility ($\sigma$)</label>
          <input type="number" id="volatility" value="1" step="0.1">
      </div>
    </div>
    
    <button class="run-btn" id="runSim">&gt; Run Simulation()</button>
    <div style="height: 1.5rem;"></div> <!-- Spacer -->
    
    <canvas id="brownianCanvas"></canvas>
    <div id="terminalOutput">&gt; System Ready. Waiting for parameters...</div>
  </div>

  <button id="backHome">&gt; return to Home</button>
</div>

<script>
// --- Toggle Mode Logic ---
const toggleBtn = document.getElementById('toggle');
let cyberpunkMode = false;

function setMode(isCyberpunk) {
  cyberpunkMode = isCyberpunk;
  document.body.classList.toggle('cyberpunk-mode', cyberpunkMode);
  toggleBtn.textContent = cyberpunkMode ? 'Matrix Mode' : 'Cyberpunk Mode';
  
  // Redraw canvas if data exists to match colors
  if (window.lastSimulationData) {
      drawBrownianPaths(window.lastSimulationData);
  }
}

// Start in Matrix Mode (Default)
setMode(false);
toggleBtn.addEventListener('click', () => setMode(!cyberpunkMode));

// --- Back Home Logic ---
document.getElementById('backHome').addEventListener('click', () => {
  const base = window.location.pathname.replace(/\/[^\/]*$/, '/');
  const homePath = new URL('./index.html', window.location.origin + base).href;
  document.body.style.opacity = '0';
  setTimeout(() => window.location.href = homePath, 350);
});

// --- Simulation Logic (Box-Muller & Canvas) ---
const canvas = document.getElementById('brownianCanvas');
const ctx = canvas.getContext('2d');
const term = document.getElementById('terminalOutput');
const runBtn = document.getElementById('runSim');

// Handle Canvas Resize
function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    canvas.logicalWidth = rect.width;
    canvas.logicalHeight = rect.height;
    
    if (window.lastSimulationData) drawBrownianPaths(window.lastSimulationData);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function boxMullerRandom() {
    let u1 = 0, u2 = Math.random();
    while(u1 === 0) u1 = Math.random();
    return Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
}

function runSimulation() {
    const numPaths = parseInt(document.getElementById('numPaths').value);
    const numSteps = parseInt(document.getElementById('numSteps').value);
    const sigma = parseFloat(document.getElementById('volatility').value);
    const T = 1.0; 
    const dt = T / numSteps;
    const sqrtDt = Math.sqrt(dt);

    const allPaths = [];
    let minW = 0, maxW = 0;
    let finalValues = [];

    // Generate Paths
    for (let p = 0; p < numPaths; p++) {
        const path = new Float32Array(numSteps + 1);
        path[0] = 0;
        for (let i = 1; i <= numSteps; i++) {
            path[i] = path[i-1] + (sigma * boxMullerRandom() * sqrtDt);
            if (path[i] < minW) minW = path[i];
            if (path[i] > maxW) maxW = path[i];
        }
        allPaths.push(path);
        finalValues.push(path[numSteps]);
    }

    const data = { allPaths, minW, maxW, numSteps, numPaths };
    window.lastSimulationData = data;
    
    drawBrownianPaths(data);
    
    // Stats
    const mean = finalValues.reduce((a,b)=>a+b,0) / numPaths;
    const variance = finalValues.reduce((a,b)=>a + (b-mean)**2, 0) / numPaths;
    
    term.textContent = `> Simulation Complete.\n`;
    term.textContent += `> Empirical Mean W(T): ${mean.toFixed(4)} (Expected: 0)\n`;
    term.textContent += `> Empirical Variance : ${variance.toFixed(4)} (Expected: ${T * sigma**2})\n`;
}

function drawBrownianPaths(data) {
    const { allPaths, minW, maxW, numSteps, numPaths } = data;
    const width = canvas.logicalWidth;
    const height = canvas.logicalHeight;
    
    ctx.clearRect(0, 0, width, height);

    // Get current theme colors
    const style = getComputedStyle(document.body);
    const accent = style.getPropertyValue('--accent').trim();
    const accentDim = style.getPropertyValue('--accent-dim').trim();
    
    const pad = 30;
    const plotW = width - pad * 2;
    const plotH = height - pad * 2;
    
    const mapX = i => pad + (i / numSteps) * plotW;
    const rangeY = (maxW - minW) || 1;
    const mapY = val => (height - pad) - ((val - minW) / rangeY) * plotH;

    // Draw Zero Line
    const zeroY = mapY(0);
    if (zeroY >= pad && zeroY <= height - pad) {
        ctx.beginPath();
        ctx.strokeStyle = accent;
        ctx.globalAlpha = 0.4;
        ctx.setLineDash([5, 5]);
        ctx.moveTo(pad, zeroY);
        ctx.lineTo(width - pad, zeroY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1.0;
    }

    // Draw Paths
    allPaths.forEach((path, idx) => {
        ctx.beginPath();
        ctx.strokeStyle = accent;
        if (idx === numPaths - 1) {
            ctx.globalAlpha = 1.0;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 8;
            ctx.shadowColor = accent;
        } else {
            ctx.globalAlpha = 0.2;
            ctx.lineWidth = 1;
            ctx.shadowBlur = 0;
        }
        ctx.moveTo(mapX(0), mapY(path[0]));
        for (let i = 1; i <= numSteps; i+=2) ctx.lineTo(mapX(i), mapY(path[i]));
        ctx.stroke();
    });
    ctx.globalAlpha = 1.0;
    ctx.shadowBlur = 0;

    // Labels
    ctx.fillStyle = accent;
    ctx.font = '10px Cascadia Code';
    ctx.textAlign = 'right';
    ctx.fillText(maxW.toFixed(2), pad - 5, mapY(maxW) + 3);
    ctx.fillText(minW.toFixed(2), pad - 5, mapY(minW) + 3);
}

runBtn.addEventListener('click', runSimulation);

// Auto-run initially
setTimeout(runSimulation, 500);

</script>
</body>
</html>