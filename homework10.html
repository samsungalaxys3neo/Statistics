<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stochastic Simulation | Poisson Process</title>
  
  <!-- Fonts -->
  <link href="https://fonts.cdnfonts.com/css/cascadia-code" rel="stylesheet">
  
  <!-- MathJax for Academic Formulas -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  
  <!-- Chart.js for Visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* --- CORE STYLE (IDENTICAL TO SOURCE) --- */
    :root {
      --bg: #0a0010;
      --accent: #b6ffb6;
      --accent-dim: rgba(182,255,182,.25);
      --glow: #b6ffb6;
      --text: #f4fff7;
      --subtitle: #8aff8a;
    }
    body.cyberpunk-mode {
      --bg: #000;
      --accent: #ff00cc;
      --accent-dim: rgba(255,0,204,.25);
      --glow: #ff00cc;
      --text: #eaffef;
      --subtitle: #ff88ff;
    }

    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      background:var(--bg);
      color:var(--text);
      font-family:'Cascadia Code', monospace;
      overflow-x:hidden;
      padding:2rem;
      transition:background .6s ease, color .6s ease;
    }

    #toggle{
      position:fixed;top:16px;right:16px;z-index:10;
      background:linear-gradient(145deg,var(--accent),var(--glow));
      color:#000;border:none;
      padding:.55rem 1rem;border-radius:10px;cursor:pointer;
      font-weight:bold;box-shadow:0 0 12px var(--glow),inset 0 0 5px rgba(255,255,255,.2);
      transition:transform .25s, box-shadow .25s;
    }
    #toggle:hover{transform:scale(1.05);box-shadow:0 0 18px var(--glow);}

    .container{
      max-width:900px;margin:6rem auto;padding:2rem 2.5rem;
      background:rgba(0,0,0,0.85);
      border:1px solid var(--accent-dim);
      border-radius:12px;
      box-shadow:0 0 20px var(--accent-dim), inset 0 0 10px rgba(255,255,255,0.05);
    }
    h1,h2,h3,h4{color:var(--accent);text-shadow:0 0 8px var(--glow);text-align:center;}
    h1{font-size:2.3rem;margin-bottom:.4rem;}
    h2{font-size:1.2rem;margin-bottom:1.8rem;opacity:.9;}
    h3{margin-top:2.2rem;margin-bottom:.8rem;color:var(--subtitle); border-bottom: 1px solid var(--accent-dim); padding-bottom: 5px; display: inline-block;}
    h4{margin-top:1rem;margin-bottom:.5rem;font-size:1rem;color:var(--subtitle);}
    p{margin-bottom:1rem; line-height: 1.6; text-align: justify;}

    /* Code Box Style */
    .sql-box{
      background:#171717;
      color:#ffffff;
      border-radius:10px;
      padding:1rem 1.2rem;
      font-family:'Cascadia Code', monospace;
      overflow-x:auto;
      margin-top:1rem;
      margin-bottom:1.5rem;
      box-shadow:inset 0 0 8px rgba(0,0,0,0.15);
      border-left: 4px solid var(--accent);
    }
    .sql-keyword{color:#0074d9;font-weight:bold;} 
    .sql-string{color:#b03060;} 
    .sql-number{color:#2e8b57;} 
    .sql-comment{color:#6a9955;font-style:italic;} 

    table{
      width:100%;
      border-collapse:collapse;
      margin-top:1rem;
      color:var(--text);
      font-size:.9rem;
    }
    th,td{
      border:1px solid var(--accent-dim);
      padding:.5rem;
      text-align:center;
    }
    th{color:var(--accent);text-shadow:0 0 6px var(--glow);}

    .btn{
      display:block;margin:1rem auto;background:transparent;border:1px solid var(--accent-dim);
      color:var(--accent);padding:.5rem .9rem;border-radius:8px;cursor:pointer;text-shadow:0 0 8px var(--glow);transition:.25s;
      font-weight: bold;
    }
    .btn:hover{background:var(--accent);color:#000;}

    #outputDemo {
      background: rgba(0, 0, 0, 0.8);
      padding: 1rem;
      border-radius: 10px;
      font-family: 'Cascadia Code', monospace;
      font-size: 0.9rem;
      line-height: 1.5;
      color: var(--accent);
      box-shadow: 0 0 15px var(--accent-dim), inset 0 0 10px rgba(255,255,255,0.05);
      white-space: pre-wrap;
      min-height: 80px;
      overflow-wrap: break-word;
      border: 1px dashed var(--accent-dim);
    }

    /* Chart Container */
    .chart-container {
      position: relative;
      height: 350px;
      width: 100%;
      margin-top: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 10px;
    }

    /* MathJax Override for Visibility */
    mjx-container {
        color: var(--text) !important;
        font-size: 1.1em !important;
    }

    /* Responsive */
    @media (max-width: 768px) {
      body { padding: 1rem; }
      .container { margin: 4rem auto; padding: 1.5rem; width: 95%; }
      h1 { font-size: 1.8rem; }
      h2 { font-size: 1rem; margin-bottom: 1rem; }
      .chart-container { height: 250px; }
    }
  </style>
</head>
<body>

<!-- Toggle Mode Button -->
<button id="toggle">Cyberpunk Mode</button>

<div class="container">
  
  <h1>Homework_10</h1>
  <h2>Approximating the Poisson Counting Process</h2>

  <h3>1. Theoretical Framework</h3>
  <p>
    A <b>Counting Process</b> \(\{N(t), t \ge 0\}\) represents the total number of "successes" (events) that have occurred up to time \(t\). We are modeling a process where events occur continuously and independently at a constant average rate \(\lambda\).
  </p>
  <p>
    The probability of observing exactly \(k\) events in a time interval of length \(T\) is given by the Poisson distribution:
  </p>
  <div style="text-align:center; margin: 1.5rem 0;">
    $$ P(N(T) = k) = e^{-\lambda T} \frac{(\lambda T)^k}{k!} $$
  </div>

  <h3>2. Numerical Approximation</h3>
  <p>
    To simulate this computationally, we discretize the continuous interval \(T\) into \(n\) infinitesimal sub-intervals of length \(\Delta t = T/n\). 
    In each sub-interval, we perform a <b>Bernoulli trial</b>.
  </p>
  
  <h4>The Limit Theorem</h4>
  <p>
    Let \(n \to \infty\) and \(p \to 0\) such that \(np = \lambda T\) remains constant. The Binomial distribution converges to the Poisson distribution:
  </p>
  <div style="text-align:center; margin: 1rem 0;">
    $$ \lim_{n \to \infty} \binom{n}{k} \left(\frac{\lambda T}{n}\right)^k \left(1 - \frac{\lambda T}{n}\right)^{n-k} = \frac{e^{-\lambda T}(\lambda T)^k}{k!} $$
  </div>

  <h3>3. Simulation Algorithm</h3>
  <p>The following logic approximates the process by iterating through \(n\) time steps.</p>
  
  <div class="sql-box">
    <span class="sql-comment">// Simulation Parameters</span><br>
    <span class="sql-keyword">const</span> T = <span class="sql-number">1.0</span>; <span class="sql-comment">// Time horizon</span><br>
    <span class="sql-keyword">const</span> lambda = <span class="sql-number">20</span>; <span class="sql-comment">// Rate parameter</span><br>
    <span class="sql-keyword">const</span> n = <span class="sql-number">5000</span>; <span class="sql-comment">// Discretization steps</span><br>
    <br>
    <span class="sql-comment">// Probability of event in dt</span><br>
    <span class="sql-keyword">const</span> p = (lambda * T) / n;<br>
    <br>
    <span class="sql-keyword">let</span> events = <span class="sql-number">0</span>;<br>
    <span class="sql-keyword">let</span> trajectory = [];<br>
    <br>
    <span class="sql-keyword">for</span> (<span class="sql-keyword">let</span> i = <span class="sql-number">0</span>; i < n; i++) {<br>
    &nbsp;&nbsp;<span class="sql-keyword">if</span> (Math.random() < p) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;events++; <span class="sql-comment">// Increment counting process</span><br>
    &nbsp;&nbsp;}<br>
    &nbsp;&nbsp;<span class="sql-comment">// Record state N(t_i) for graphing</span><br>
    &nbsp;&nbsp;trajectory.push({x: (i/n)*T, y: events});<br>
    }<br>
  </div>

  <h3>4. Runtime Simulation</h3>
  <p>Click below to run a stochastic simulation with \(n=1000\) sub-intervals and \(\lambda=10\). The graph visualizes the sample path (trajectory) of \(N(t)\).</p>
  
  <button class="btn" id="runDemo">&gt; Execute Simulation()</button>
  
  <div class="chart-container">
    <canvas id="poissonChart"></canvas>
  </div>
  <br>
  <pre id="outputDemo"></pre>

  <h3>5. Analysis & Interpretation</h3>
  
  <h4>Interpretation of \(\lambda\)</h4>
  <p>
    The parameter \(\lambda\) is the <b>intensity rate</b>. It represents the expected number of arrivals per unit of time.
    <br>
    $$ E[N(t)] = \lambda t \quad \text{and} \quad Var(N(t)) = \lambda t $$
  </p>

  <h4>Stochastic Properties</h4>
  <ul>
    <li><b>Stationarity:</b> The distribution of events depends only on the interval length, not the start time.</li>
    <li><b>Independent Increments:</b> Occurrences in disjoint time intervals are statistically independent.</li>
    <li><b>Rare Events:</b> The probability of \(>1\) event occurring in \(\Delta t\) is \(o(\Delta t)\) (negligible).</li>
  </ul>

</div>

<script>
// GLOBAL DECLARATION: Moved to top to prevent ReferenceError in setMode
let myChart = null;

// --- PART 1: Style & Toggle Mode ---
const toggleBtn = document.getElementById('toggle');
let cyberpunkMode = false;

// Function to get current colors for the chart
function getThemeColors() {
  const style = getComputedStyle(document.body);
  return {
    accent: style.getPropertyValue('--accent').trim(),
    text: style.getPropertyValue('--text').trim(),
    grid: style.getPropertyValue('--accent-dim').trim()
  };
}

function setMode(isCyberpunk) {
  cyberpunkMode = isCyberpunk;
  document.body.classList.toggle('cyberpunk-mode', cyberpunkMode);
  toggleBtn.textContent = cyberpunkMode ? 'Matrix Mode' : 'Cyberpunk Mode';
  
  // Update chart if it exists
  if(myChart) {
    const colors = getThemeColors();
    myChart.data.datasets[0].borderColor = colors.accent;
    myChart.data.datasets[0].backgroundColor = colors.accent;
    myChart.options.scales.x.grid.color = colors.grid;
    myChart.options.scales.y.grid.color = colors.grid;
    myChart.options.scales.x.ticks.color = colors.text;
    myChart.options.scales.y.ticks.color = colors.text;
    myChart.update();
  }
}
setMode(false); 
toggleBtn.addEventListener('click', () => setMode(!cyberpunkMode));


// --- PART 2: Typewriter Effect ---
function typeWriter(element, text, speed = 10) {
  if (!element) return;
  element.textContent = '';
  let i = 0;
  const cursor = document.createElement('span');
  cursor.textContent = '█'; 
  element.appendChild(cursor);

  const interval = setInterval(() => {
    if (i < text.length) {
      element.textContent = text.substring(0, i + 1) + '█';
      i++;
    } else {
      clearInterval(interval);
      element.textContent = text;
    }
  }, speed);
}

// --- PART 3: Simulation Logic & Chart.js ---
const demoBtn = document.getElementById('runDemo');
const demoOutput = document.getElementById('outputDemo');
const ctx = document.getElementById('poissonChart').getContext('2d');

if (demoBtn && demoOutput) {
  demoBtn.addEventListener('click', () => {
    // 1. Define Parameters
    const n = 1000;       // Granularity
    const lambda = 10;    // Rate
    const T = 1.0;        // Time interval
    const p = (lambda * T) / n; // Prob per micro-slot

    // 2. Execute Simulation
    let events = 0;
    let dataPoints = [{x: 0, y: 0}]; // Start at 0,0
    
    for(let i = 0; i < n; i++) {
        // Bernoulli Trial
        if(Math.random() < p) {
            events++;
        }
        // Add point for step chart (Normalized time 0 to 1)
        dataPoints.push({x: (i+1)/n * T, y: events});
    }

    // 3. Theoretical Stats
    const expected = lambda * T;
    const variance = lambda * T;
    const error = ((events - expected)/expected * 100).toFixed(2);

    // 4. Render Chart
    const colors = getThemeColors();
    
    if(myChart) myChart.destroy();

    myChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: 'N(t) Trajectory',
                data: dataPoints,
                borderColor: colors.accent,
                backgroundColor: colors.accent,
                borderWidth: 2,
                stepped: true, // Crucial for Counting Process visualization
                pointRadius: 0, // Hide individual dots for clean line
                fill: false,
                tension: 0
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 1000, easing: 'linear' },
            plugins: {
                legend: { labels: { color: colors.text, font: { family: 'Cascadia Code' } } }
            },
            scales: {
                x: {
                    type: 'linear',
                    min: 0, max: T,
                    grid: { color: colors.grid },
                    ticks: { color: colors.text, font: { family: 'Cascadia Code' } },
                    title: { display: true, text: 'Time (t)', color: colors.accent }
                },
                y: {
                    min: 0,
                    // Add some headroom above max events
                    suggestedMax: expected + Math.sqrt(variance)*2, 
                    grid: { color: colors.grid },
                    ticks: { color: colors.text, font: { family: 'Cascadia Code' } },
                    title: { display: true, text: 'Count N(t)', color: colors.accent }
                }
            }
        }
    });

    // 5. Text Output
    const log = `> SYSTEM: Initializing Stochastic Environment...\n` +
                `> PARAMETERS: T=${T}, n=${n}, λ=${lambda}\n` +
                `> COMPUTING: Generating ${n} Bernoulli trials...\n` +
                `> -------------------------------------------\n` +
                `> RESULT: Total Events N(T) = ${events}\n` +
                `> THEORY: Expected E[N(T)]  = ${expected}\n` +
                `> STATUS: Deviation ${error}% ${Math.abs(error) < 10 ? '[ACCEPTABLE]' : '[HIGH VARIANCE]'}\n` +
                `> PROCESS: Converged to Poisson Distribution.`;
    
    typeWriter(demoOutput, log, 5);
  });
}


// --- PART 4: Return Home Button (PRESERVED) ---
const returnBtn = document.createElement('button');
returnBtn.className = 'btn';
returnBtn.id = 'backHome';
returnBtn.textContent = '> return Home';
returnBtn.style.marginTop = '1.6rem';

const container = document.querySelector('.container');
if (container) {
  container.appendChild(returnBtn);
  document.getElementById('backHome').addEventListener('click', () => {
    window.location.href = './index.html'; 
  });
}

</script>
</body>
</html>